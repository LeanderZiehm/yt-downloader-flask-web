>>> from pytubefix import YouTube
Now, let’s try to download a video. For this example, let’s take something like the YouTube Rewind video for 2019:
>>> yt = YouTube('http://youtube.com/watch?v=2lAe1cqCOXo')
Now, we have a YouTube object called yt.
The pytubefix API makes all information intuitive to access. For example, this is how you would get the video’s title:
>>> yt.title
YouTube Rewind 2019: For the Record | #YouTubeRewind
And this would be how you would get the thumbnail url:
>>> yt.thumbnail_url
'https://i.ytimg.com/vi/2lAe1cqCOXo/maxresdefault.jpg'
Neat, right? For advanced use cases, you can provide some additional arguments when you create a YouTube object:
>>> yt = YouTube(
'http://youtube.com/watch?v=2lAe1cqCOXo',
on_progress_callback=progress_func,
on_complete_callback=complete_func,
proxies=my_proxies,
use_oauth=False,
allow_oauth_cache=True
)
When instantiating a YouTube object, these named arguments can be passed in to improve functionality.
The on_progress_callback function will run whenever a chunk is downloaded from a video, and is called with three
arguments: the stream, the data chunk, and the bytes remaining in the video. This could be used, for example, to display
a progress bar.
The on_complete_callback function will run after a video has been fully downloaded, and is called with two arguments:
the stream and the file path. This could be used, for example, to perform post-download processing on a video like
trimming the length of it.
The use_oauth and allow_oauth_cache flags allow you to authorize pytubefix to interact with YouTube using your
account, and can be used to bypass age restrictions or access private videos and playlists. If allow_oauth_cache is set
to True, you should only be prompted to do so once, after which point pytubefix will cache the tokens it needs to act
on your behalf. Otherwise, you will be prompted again for each action that requires you to be authenticated.
Once you have a YouTube object set up, you’re ready to start looking at different media streams for the video, which is
discussed in the next section.
2.3 Working with Streams and StreamQuery
The next section will explore the various options available for working with media streams, but before we can dive
in, we need to review a new-ish streaming technique adopted by YouTube. It assumes that you have already created a
YouTube object in your code called “yt”.
6 Chapter 2. The User Guide
pytubefix Documentation, Release 8.12.3
2.3.1 DASH vs Progressive Streams
Begin by running the following to list all streams:
>>> yt.streams
[<Stream: itag="18" mime_type="video/mp4" res="360p" fps="30fps" vcodec="avc1.42001E"␣
˓→acodec="mp4a.40.2" progressive="True" type="video">,
<Stream: itag="22" mime_type="video/mp4" res="720p" fps="30fps" vcodec="avc1.64001F"␣
˓→acodec="mp4a.40.2" progressive="True" type="video">,
<Stream: itag="137" mime_type="video/mp4" res="1080p" fps="30fps" vcodec="avc1.640028"␣
˓→progressive="False" type="video">,
...
<Stream: itag="250" mime_type="audio/webm" abr="70kbps" acodec="opus" progressive="False
˓→" type="audio">,
<Stream: itag="251" mime_type="audio/webm" abr="160kbps" acodec="opus" progressive="False
˓→" type="audio">]
You may notice that some streams listed have both a video codec and audio codec, while others have just video or just
audio, this is a result of YouTube supporting a streaming technique called Dynamic Adaptive Streaming over HTTP
(DASH).
In the context of pytubefix, the implications are for the highest quality streams; you now need to download both the
audio and video tracks and then post-process them with software like FFmpeg to merge them.
The legacy streams that contain the audio and video in a single file (referred to as “progressive download”) are still
available, but only for resolutions 720p and below.
2.4 Filtering Streams
pytubefix has built-in functionality to filter the streams available in a YouTube object with the .filter() method. You
can pass it a number of different keyword arguments, so let’s review some of the different options you’re most likely
to use. For a complete list of available properties to filter on, you can view the API documentation here: pytubefix.
StreamQuery.filter().
2.4.1 Filtering by streaming method
As mentioned before, progressive streams have the video and audio in a single file, but typically do not provide the
highest quality media; meanwhile, adaptive streams split the video and audio tracks but can provide much higher quality.
pytubefix makes it easy to filter based on the type of stream that you’re interested.
For example, you can filter to only progressive streams with the following:
>>> yt.streams.filter(progressive=True)
[<Stream: itag="18" mime_type="video/mp4" res="360p" fps="30fps" vcodec="avc1.42001E"␣
˓→acodec="mp4a.40.2" progressive="True" type="video">,
<Stream: itag="22" mime_type="video/mp4" res="720p" fps="30fps" vcodec="avc1.64001F"␣
˓→acodec="mp4a.40.2" progressive="True" type="video">]
Conversely, if you only want to see the DASH streams (also referred to as “adaptive”) you can do:
>>> yt.streams.filter(adaptive=True)
[<Stream: itag="137" mime_type="video/mp4" res="1080p" fps="30fps" vcodec="avc1.640028"␣
˓→progressive="False" type="video">,
<Stream: itag="248" mime_type="video/webm" res="1080p" fps="30fps" vcodec="vp9"␣
˓→progressive="False" type="video">,
(continues on next page)
2.4. Filtering Streams 7
pytubefix Documentation, Release 8.12.3
(continued from previous page)
<Stream: itag="399" mime_type="video/mp4" res="None" fps="30fps" vcodec="av01.0.08M.08"␣
˓→progressive="False" type="video">,
...
<Stream: itag="250" mime_type="audio/webm" abr="70kbps" acodec="opus" progressive="False
˓→" type="audio">,
<Stream: itag="251" mime_type="audio/webm" abr="160kbps" acodec="opus" progressive="False
˓→" type="audio">]
2.4.2 Filtering for audio-only streams
To query the streams that contain only the audio track:
>>> yt.streams.filter(only_audio=True)
[<Stream: itag="140" mime_type="audio/mp4" abr="128kbps" acodec="mp4a.40.2" progressive=
˓→"False" type="audio">,
<Stream: itag="249" mime_type="audio/webm" abr="50kbps" acodec="opus" progressive="False
˓→" type="audio">,
<Stream: itag="250" mime_type="audio/webm" abr="70kbps" acodec="opus" progressive="False
˓→" type="audio">,
<Stream: itag="251" mime_type="audio/webm" abr="160kbps" acodec="opus" progressive="False
˓→" type="audio">]
2.4.3 Filtering for MP4 streams
To query only streams in the MP4 format:
>>> yt.streams.filter(file_extension='mp4')
[<Stream: itag="18" mime_type="video/mp4" res="360p" fps="30fps" vcodec="avc1.42001E"␣
˓→acodec="mp4a.40.2" progressive="True" type="video">,
<Stream: itag="22" mime_type="video/mp4" res="720p" fps="30fps" vcodec="avc1.64001F"␣
˓→acodec="mp4a.40.2" progressive="True" type="video">,
<Stream: itag="137" mime_type="video/mp4" res="1080p" fps="30fps" vcodec="avc1.640028"␣
˓→progressive="False" type="video">,
...
<Stream: itag="394" mime_type="video/mp4" res="None" fps="30fps" vcodec="av01.0.00M.08"␣
˓→progressive="False" type="video">,
<Stream: itag="140" mime_type="audio/mp4" abr="128kbps" acodec="mp4a.40.2" progressive=
˓→"False" type="audio">]
2.5 Downloading Streams
After you’ve selected the Stream you’re interested, you’re ready to interact with it. At this point, you can query
information about the stream, such as its filesize, whether the stream is adaptive, and more. You can also use the
download method to save the file:
>>> stream = yt.streams.get_by_itag(22)
>>> stream.download()
The download method has a number of different useful arguments, which are documented in the API refere